#+TITLE: Yet Another Color Forth (yacf)

This is a toy project aimed on exploration.

* Features
- source in tagged ("coloured") words :: 32 bit words contain 3-bit
     tag and 29 bit name
  + limited set of characters that can be 4,5, or 7 bits long (very
    similar to what Moore used)
  + source can be edited directly in emacs =yacf-mode=
  + source used to be and to some extent still is organized in 512
    bytes (128 words) long pages that can be loaded;
- self compiling :: Able to compile itself from the source
  + bootstrapping was done originally in assembler, but this
    scaffolding was already removed
- stack based :: system stack for control stack, other
     register stack index for data stack
- two heaps (or more) :: separate data heap and code heap
- x86 as build host :: actually, x86 means Intel Atomâ„¢ processor.
- machine code with Linux elf as target :: the interface to target
     hardware are syscalls. No library expected nor used.
- no BASE :: numbers are explicitly decimal or hexadecimal, both on
             input (different color) and output (different words).
- no STATE :: green words are compiled, yellow are executed
- tail call optimization :: if semicolon to be compiled follows
     compiled call to word, jump is compiled instead. This allows to
     delay for some time real definition of semicolon in
     bootstrapping.
* Quick start
- To rebuild the =yacf= binary (possibly after changes to =yacf.blk=), do 
  : ./yacf compile.blk yacf.blk 4> yacf-copy
- To view the source file content in human readable form (with ansi colors), do
  : ./yacf list.blk <something>.blk
- The ANSI sequenced text can be viewed in emacs with 
  : (ansi-color-apply-on-region (point-min) (point-max))
- To edit source files in emacs, load =yacf.el= and =yacf-load= the source
  file (this has rough edges still). Normal opening and setting
  =yacf-mode= later had some problems due to character set.
- To allow git diff to work on the block files, do 
  : git config diff.blk.textconv "./yacf list.blk".
- To ensure that the bootstraping works, do =make check=. It will
  rebuild new =yacf= under name =future=, and then tries to use the =future=
  to build it again and compare results. They should be same.
* [3/6] Immediate plans
- [X] Compile elf binary
- [X] Output buffer words
- [X] Compile itself as a binary
- [ ] Compile arm binary
- [ ] Compile pic (Microchip) binary - it was working some time ago,
     but got lost.
- [ ] Ensure alignment
** Not planned for now
- Make editor to edit blocks :: emacs mode will do.
- section headers for elf :: they are not used for execution of
     file. Objdump complains, so what?
* Bugs
- not clean usefulness. Did I say toy project?
- semicolon after call to word with a long name is not optimzied to
  jump
* Tagging
Tag is in lower 3 bits of the word (or, assuming small endiannes, of
the first octet of the word. It is interpreted as:

| Tag | Color             | Interpretation       |
|-----+-------------------+----------------------|
|   0 | same as preceding | continuation of word |
|   1 | yellow            | decimal number       |
|   2 | green             | [[id:eb311d0c-1626-4b1a-bb16-5500ffac4d40][compiled word]]        |
|   3 | black bold        | defined word         |
|   4 | black             | editor word          |
|   5 | black             | comment              |
|   6 | yellow            | hexadecimal number   |
|   7 | yellow            | word to execute      |

** Green words
   :PROPERTIES:
   :ID:       eb311d0c-1626-4b1a-bb16-5500ffac4d40
   :END:
The green words are searched for in several dictionaries:
- if it follows a yellow word, ~nrmacros~ dictionary is searched
  - if the word is found there, the word is executed
  - otherwise, the code to push number on stack is compiled, and green
    word is handled as if it would not follow yellow word, that is,
- if the word is found in ~macros~ dictionary, execute it;
- if not, find it in ~forth~ vocabulary and compile a call to it
- or fail, preferably loudly
* Elf binary
|     VMA | Contains               |
|---------+------------------------|
| 0x20000 | Elf header             |
| 0x20054 | last dictionary VMA    |
| 0x20060 | addresses of tag words |
| 0x20080 | words code             |
|    init | init code              |
|     ..0 | dictionary             |
|     ... | ...                    |
| 0x21000 | pages area
|         | output buffer          |
| 0x30000 | random variables       |
|         | stack                  |
| 0x30100 | end                    |

* x86 assembler low level words
Legend: ~o~ is signed octet, ~w~ is word
** x86 registers
| reg | use                           |
|-----+-------------------------------|
| eax | TOP of data stack             |
| esp | pointer below bottom stack    |
| ebx | pointer below data stack      |
| esi | A register - address to read  |
| edi | B register - address to write |

** Builder words
These are forth words that put te code
| forth       | x86               | usage                |
|-------------+-------------------+----------------------|
| ~,put~      | mov %eax, (%ebx)  | ~dup~ component        |
| /n/ ~,+stack~ | lea n(%ebx), %ebx | ~nip~, ...             |
| n ~,lit~    | ~dup~ mov $n,%eax   | yellow to green, ... |
| ~op~ ,rot   | <op> %cl,%eax     | shl, rot, ...        |
| tocl        | mov %eax,%ecx     |                      |

** Number macros
| forth       | x86 assembler                          |
|-------------+----------------------------------------|
| n +         | add n, %eax                            |
| w +l        | add w, %eax                            |
| o +@        | mov n(eax), %eax                       |
| o nth       | mov o(%ebx), %eax                      |
| w @-+       | sub w, %eax                            |
| w @         | <dup>; mov w, %eax                     |
| o ash       | sar o, %eax                            |
| o lsr       | shr o, %eax                            |
| o shl       | shl o, %eax                            |
| o and       | and o, %eax                            |
| w /         | xor %edx, %edx; mov $w, %ecx; div %ecx |
| w cmp       | cmp $w, %eax                           |
| <reg> reg!  | mov (%ebx), <reg>                      |
| <reg> ldreg | mov <reg>, %eax                        |
| <reg> pop   | pop <reg>                              |
| <reg> push  | push <reg>                             |
| a !         | mov %eax,a ~drop~                        |
| a w !!      | mov $w,  a                             |

** Macros
| forth | x86 assembler              |
|-------+----------------------------|
| ~;~     | ret                        |
| ~over+~ | add 4(%ebx), %eax          |
| ~/xor/~ | xor 4(%ebx), %eax          |
| ~!cl~   | mov %cl, (%eax)            |
| ~!ecx~  | mov %ecx, (%eax)           |
| ~break~ | int 0x3                    |
| ~@~     | mov (%eax), %eax           |
| ~-~     | neg %eax                   |
| ~1-~    | dec %eax                   |
| ~/reg/~ | lea 0(%ebp, %eax, 4), %eax |
| ~/sys/~ | mov 0xc(%ebx), %edx        |
|       | mov 0x8(%ebx), %ecx        |
|       | mov 0x4(%ebx), %ebx        |
|       | int 0x80                   |
| ~da@+~  | mov (%edi), %eax           |
|       | lea 4(%edi), %edi          |
| ~da!~   | mov %eax, %edi             |
|       |                            |

Note: ~/reg/~ could be possibly even better defined as an number
macro. However, it would need to change the stack size.

* Forth registers
Words starting at #x30000
|  0 | Vocabulary index                 |
|  1 | Top of heap                      |
|  2 | Immediate words                  |
|  3 | Top of data heap                 |
|  4 | Link to vocabulary for new words |
|  5 | Output buffer bottom             |
|  6 | Number macros vocabulary         |


  
* Notes
** Notes on some words
- 
- empty :: First word in given vocabulary needs to have its own
           address in the word link. This takes care of it.
** Elementary macros
- +s and + :: Two bytes can be saved if short form of addition is
              used. Not sure if it is worthy doing, though.

